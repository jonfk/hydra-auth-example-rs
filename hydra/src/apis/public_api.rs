/*
 * ORY Hydra
 *
 * Welcome to the ORY Hydra HTTP API documentation. You will find documentation for all HTTP APIs here.
 *
 * The version of the OpenAPI document: latest
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use reqwest;

use super::{Error, configuration};

pub struct PublicApiClient {
    configuration: Rc<configuration::Configuration>,
}

impl PublicApiClient {
    pub fn new(configuration: Rc<configuration::Configuration>) -> PublicApiClient {
        PublicApiClient {
            configuration,
        }
    }
}

pub trait PublicApi {
    fn disconnect_user(&self, ) -> Result<(), Error>;
    fn discover_open_id_configuration(&self, ) -> Result<crate::models::WellKnown, Error>;
    fn is_instance_ready(&self, ) -> Result<crate::models::HealthStatus, Error>;
    fn oauth2_token(&self, grant_type: &str, code: Option<&str>, refresh_token: Option<&str>, redirect_uri: Option<&str>, client_id: Option<&str>) -> Result<crate::models::Oauth2TokenResponse, Error>;
    fn oauth_auth(&self, ) -> Result<(), Error>;
    fn revoke_o_auth2_token(&self, token: &str) -> Result<(), Error>;
    fn userinfo(&self, ) -> Result<crate::models::UserinfoResponse, Error>;
    fn well_known(&self, ) -> Result<crate::models::JsonWebKeySet, Error>;
}

impl PublicApi for PublicApiClient {
    fn disconnect_user(&self, ) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/oauth2/sessions/logout", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn discover_open_id_configuration(&self, ) -> Result<crate::models::WellKnown, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/.well-known/openid-configuration", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn is_instance_ready(&self, ) -> Result<crate::models::HealthStatus, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/health/ready", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn oauth2_token(&self, grant_type: &str, code: Option<&str>, refresh_token: Option<&str>, redirect_uri: Option<&str>, client_id: Option<&str>) -> Result<crate::models::Oauth2TokenResponse, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/oauth2/token", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref auth_conf) = configuration.basic_auth {
            req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
        };
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        form_params.insert("grant_type", grant_type.to_string());
        if let Some(param_value) = code {
            form_params.insert("code", param_value.to_string());
        }
        if let Some(param_value) = refresh_token {
            form_params.insert("refresh_token", param_value.to_string());
        }
        if let Some(param_value) = redirect_uri {
            form_params.insert("redirect_uri", param_value.to_string());
        }
        if let Some(param_value) = client_id {
            form_params.insert("client_id", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn oauth_auth(&self, ) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/oauth2/auth", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn revoke_o_auth2_token(&self, token: &str) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/oauth2/revoke", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref auth_conf) = configuration.basic_auth {
            req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
        };
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        form_params.insert("token", token.to_string());
        req_builder = req_builder.form(&form_params);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn userinfo(&self, ) -> Result<crate::models::UserinfoResponse, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/userinfo", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn well_known(&self, ) -> Result<crate::models::JsonWebKeySet, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/.well-known/jwks.json", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

}
